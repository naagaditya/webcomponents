(function () {
    'use strict';

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    // The first argument to JS template tags retain identity across multiple
    // calls to a tag for the same literal, so we can cache work done per literal
    // in a Map.
    const templateCaches = new Map();
    /**
     * The return type of `html`, which holds a Template and the values from
     * interpolated expressions.
     */
    class TemplateResult {
        constructor(strings, values, type, partCallback = defaultPartCallback) {
            this.strings = strings;
            this.values = values;
            this.type = type;
            this.partCallback = partCallback;
        }
        /**
         * Returns a string of HTML used to create a <template> element.
         */
        getHTML() {
            const l = this.strings.length - 1;
            let html = '';
            let isTextBinding = true;
            for (let i = 0; i < l; i++) {
                const s = this.strings[i];
                html += s;
                // We're in a text position if the previous string closed its tags.
                // If it doesn't have any tags, then we use the previous text position
                // state.
                const closing = findTagClose(s);
                isTextBinding = closing > -1 ? closing < s.length : isTextBinding;
                html += isTextBinding ? nodeMarker : marker;
            }
            html += this.strings[l];
            return html;
        }
        getTemplateElement() {
            const template = document.createElement('template');
            template.innerHTML = this.getHTML();
            return template;
        }
    }
    /**
     * The default TemplateFactory which caches Templates keyed on
     * result.type and result.strings.
     */
    function defaultTemplateFactory(result) {
        let templateCache = templateCaches.get(result.type);
        if (templateCache === undefined) {
            templateCache = new Map();
            templateCaches.set(result.type, templateCache);
        }
        let template = templateCache.get(result.strings);
        if (template === undefined) {
            template = new Template(result, result.getTemplateElement());
            templateCache.set(result.strings, template);
        }
        return template;
    }
    /**
     * Renders a template to a container.
     *
     * To update a container with new values, reevaluate the template literal and
     * call `render` with the new result.
     *
     * @param result a TemplateResult created by evaluating a template tag like
     *     `html` or `svg`.
     * @param container A DOM parent to render to. The entire contents are either
     *     replaced, or efficiently updated if the same result type was previous
     *     rendered there.
     * @param templateFactory a function to create a Template or retreive one from
     *     cache.
     */
    function render(result, container, templateFactory = defaultTemplateFactory) {
        const template = templateFactory(result);
        let instance = container.__templateInstance;
        // Repeat render, just call update()
        if (instance !== undefined && instance.template === template &&
            instance._partCallback === result.partCallback) {
            instance.update(result.values);
            return;
        }
        // First render, create a new TemplateInstance and append it
        instance =
            new TemplateInstance(template, result.partCallback, templateFactory);
        container.__templateInstance = instance;
        const fragment = instance._clone();
        instance.update(result.values);
        removeNodes(container, container.firstChild);
        container.appendChild(fragment);
    }
    /**
     * An expression marker with embedded unique key to avoid collision with
     * possible text in templates.
     */
    const marker = `{{lit-${String(Math.random()).slice(2)}}}`;
    /**
     * An expression marker used text-positions, not attribute positions,
     * in template.
     */
    const nodeMarker = `<!--${marker}-->`;
    const markerRegex = new RegExp(`${marker}|${nodeMarker}`);
    /**
     * This regex extracts the attribute name preceding an attribute-position
     * expression. It does this by matching the syntax allowed for attributes
     * against the string literal directly preceding the expression, assuming that
     * the expression is in an attribute-value position.
     *
     * See attributes in the HTML spec:
     * https://www.w3.org/TR/html5/syntax.html#attributes-0
     *
     * "\0-\x1F\x7F-\x9F" are Unicode control characters
     *
     * " \x09\x0a\x0c\x0d" are HTML space characters:
     * https://www.w3.org/TR/html5/infrastructure.html#space-character
     *
     * So an attribute is:
     *  * The name: any character except a control character, space character, ('),
     *    ("), ">", "=", or "/"
     *  * Followed by zero or more space characters
     *  * Followed by "="
     *  * Followed by zero or more space characters
     *  * Followed by:
     *    * Any character except space, ('), ("), "<", ">", "=", (`), or
     *    * (") then any non-("), or
     *    * (') then any non-(')
     */
    const lastAttributeNameRegex = /[ \x09\x0a\x0c\x0d]([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)[ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*)$/;
    /**
     * Finds the closing index of the last closed HTML tag.
     * This has 3 possible return values:
     *   - `-1`, meaning there is no tag in str.
     *   - `string.length`, meaning the last opened tag is unclosed.
     *   - Some positive number < str.length, meaning the index of the closing '>'.
     */
    function findTagClose(str) {
        const close = str.lastIndexOf('>');
        const open = str.indexOf('<', close + 1);
        return open > -1 ? str.length : close;
    }
    /**
     * A placeholder for a dynamic expression in an HTML template.
     *
     * There are two built-in part types: AttributePart and NodePart. NodeParts
     * always represent a single dynamic expression, while AttributeParts may
     * represent as many expressions are contained in the attribute.
     *
     * A Template's parts are mutable, so parts can be replaced or modified
     * (possibly to implement different template semantics). The contract is that
     * parts can only be replaced, not removed, added or reordered, and parts must
     * always consume the correct number of values in their `update()` method.
     *
     * TODO(justinfagnani): That requirement is a little fragile. A
     * TemplateInstance could instead be more careful about which values it gives
     * to Part.update().
     */
    class TemplatePart {
        constructor(type, index, name, rawName, strings) {
            this.type = type;
            this.index = index;
            this.name = name;
            this.rawName = rawName;
            this.strings = strings;
        }
    }
    const isTemplatePartActive = (part) => part.index !== -1;
    /**
     * An updateable Template that tracks the location of dynamic parts.
     */
    class Template {
        constructor(result, element) {
            this.parts = [];
            this.element = element;
            const content = this.element.content;
            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
            const walker = document.createTreeWalker(content, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |
                   NodeFilter.SHOW_TEXT */, null, false);
            let index = -1;
            let partIndex = 0;
            const nodesToRemove = [];
            // The actual previous node, accounting for removals: if a node is removed
            // it will never be the previousNode.
            let previousNode;
            // Used to set previousNode at the top of the loop.
            let currentNode;
            while (walker.nextNode()) {
                index++;
                previousNode = currentNode;
                const node = currentNode = walker.currentNode;
                if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
                    if (!node.hasAttributes()) {
                        continue;
                    }
                    const attributes = node.attributes;
                    // Per https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
                    // attributes are not guaranteed to be returned in document order. In
                    // particular, Edge/IE can return them out of order, so we cannot assume
                    // a correspondance between part index and attribute index.
                    let count = 0;
                    for (let i = 0; i < attributes.length; i++) {
                        if (attributes[i].value.indexOf(marker) >= 0) {
                            count++;
                        }
                    }
                    while (count-- > 0) {
                        // Get the template literal section leading up to the first
                        // expression in this attribute
                        const stringForPart = result.strings[partIndex];
                        // Find the attribute name
                        const attributeNameInPart = lastAttributeNameRegex.exec(stringForPart)[1];
                        // Find the corresponding attribute
                        // TODO(justinfagnani): remove non-null assertion
                        const attribute = attributes.getNamedItem(attributeNameInPart);
                        const stringsForAttributeValue = attribute.value.split(markerRegex);
                        this.parts.push(new TemplatePart('attribute', index, attribute.name, attributeNameInPart, stringsForAttributeValue));
                        node.removeAttribute(attribute.name);
                        partIndex += stringsForAttributeValue.length - 1;
                    }
                }
                else if (node.nodeType === 3 /* Node.TEXT_NODE */) {
                    const nodeValue = node.nodeValue;
                    if (nodeValue.indexOf(marker) < 0) {
                        continue;
                    }
                    const parent = node.parentNode;
                    const strings = nodeValue.split(markerRegex);
                    const lastIndex = strings.length - 1;
                    // We have a part for each match found
                    partIndex += lastIndex;
                    // Generate a new text node for each literal section
                    // These nodes are also used as the markers for node parts
                    for (let i = 0; i < lastIndex; i++) {
                        parent.insertBefore((strings[i] === '')
                            ? document.createComment('')
                            : document.createTextNode(strings[i]), node);
                        this.parts.push(new TemplatePart('node', index++));
                    }
                    parent.insertBefore(strings[lastIndex] === '' ?
                        document.createComment('') :
                        document.createTextNode(strings[lastIndex]), node);
                    nodesToRemove.push(node);
                }
                else if (node.nodeType === 8 /* Node.COMMENT_NODE */ &&
                    node.nodeValue === marker) {
                    const parent = node.parentNode;
                    // Add a new marker node to be the startNode of the Part if any of the
                    // following are true:
                    //  * We don't have a previousSibling
                    //  * previousSibling is being removed (thus it's not the
                    //    `previousNode`)
                    //  * previousSibling is not a Text node
                    //
                    // TODO(justinfagnani): We should be able to use the previousNode here
                    // as the marker node and reduce the number of extra nodes we add to a
                    // template. See https://github.com/PolymerLabs/lit-html/issues/147
                    const previousSibling = node.previousSibling;
                    if (previousSibling === null || previousSibling !== previousNode ||
                        previousSibling.nodeType !== Node.TEXT_NODE) {
                        parent.insertBefore(document.createComment(''), node);
                    }
                    else {
                        index--;
                    }
                    this.parts.push(new TemplatePart('node', index++));
                    nodesToRemove.push(node);
                    // If we don't have a nextSibling add a marker node.
                    // We don't have to check if the next node is going to be removed,
                    // because that node will induce a new marker if so.
                    if (node.nextSibling === null) {
                        parent.insertBefore(document.createComment(''), node);
                    }
                    else {
                        index--;
                    }
                    currentNode = previousNode;
                    partIndex++;
                }
            }
            // Remove text binding nodes after the walk to not disturb the TreeWalker
            for (const n of nodesToRemove) {
                n.parentNode.removeChild(n);
            }
        }
    }
    /**
     * Returns a value ready to be inserted into a Part from a user-provided value.
     *
     * If the user value is a directive, this invokes the directive with the given
     * part. If the value is null, it's converted to undefined to work better
     * with certain DOM APIs, like textContent.
     */
    const getValue = (part, value) => {
        // `null` as the value of a Text node will render the string 'null'
        // so we convert it to undefined
        if (isDirective(value)) {
            value = value(part);
            return noChange;
        }
        return value === null ? undefined : value;
    };
    const directive = (f) => {
        f.__litDirective = true;
        return f;
    };
    const isDirective = (o) => typeof o === 'function' && o.__litDirective === true;
    /**
     * A sentinel value that signals that a value was handled by a directive and
     * should not be written to the DOM.
     */
    const noChange = {};
    const isPrimitiveValue = (value) => value === null ||
        !(typeof value === 'object' || typeof value === 'function');
    class AttributePart {
        constructor(instance, element, name, strings) {
            this.instance = instance;
            this.element = element;
            this.name = name;
            this.strings = strings;
            this.size = strings.length - 1;
            this._previousValues = [];
        }
        _interpolate(values, startIndex) {
            const strings = this.strings;
            const l = strings.length - 1;
            let text = '';
            for (let i = 0; i < l; i++) {
                text += strings[i];
                const v = getValue(this, values[startIndex + i]);
                if (v && v !== noChange &&
                    (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {
                    for (const t of v) {
                        // TODO: we need to recursively call getValue into iterables...
                        text += t;
                    }
                }
                else {
                    text += v;
                }
            }
            return text + strings[l];
        }
        _equalToPreviousValues(values, startIndex) {
            for (let i = startIndex; i < startIndex + this.size; i++) {
                if (this._previousValues[i] !== values[i] ||
                    !isPrimitiveValue(values[i])) {
                    return false;
                }
            }
            return true;
        }
        setValue(values, startIndex) {
            if (this._equalToPreviousValues(values, startIndex)) {
                return;
            }
            const s = this.strings;
            let value;
            if (s.length === 2 && s[0] === '' && s[1] === '') {
                // An expression that occupies the whole attribute value will leave
                // leading and trailing empty strings.
                value = getValue(this, values[startIndex]);
                if (Array.isArray(value)) {
                    value = value.join('');
                }
            }
            else {
                value = this._interpolate(values, startIndex);
            }
            if (value !== noChange) {
                this.element.setAttribute(this.name, value);
            }
            this._previousValues = values;
        }
    }
    class NodePart {
        constructor(instance, startNode, endNode) {
            this.instance = instance;
            this.startNode = startNode;
            this.endNode = endNode;
            this._previousValue = undefined;
        }
        setValue(value) {
            value = getValue(this, value);
            if (value === noChange) {
                return;
            }
            if (isPrimitiveValue(value)) {
                // Handle primitive values
                // If the value didn't change, do nothing
                if (value === this._previousValue) {
                    return;
                }
                this._setText(value);
            }
            else if (value instanceof TemplateResult) {
                this._setTemplateResult(value);
            }
            else if (Array.isArray(value) || value[Symbol.iterator]) {
                this._setIterable(value);
            }
            else if (value instanceof Node) {
                this._setNode(value);
            }
            else if (value.then !== undefined) {
                this._setPromise(value);
            }
            else {
                // Fallback, will render the string representation
                this._setText(value);
            }
        }
        _insert(node) {
            this.endNode.parentNode.insertBefore(node, this.endNode);
        }
        _setNode(value) {
            if (this._previousValue === value) {
                return;
            }
            this.clear();
            this._insert(value);
            this._previousValue = value;
        }
        _setText(value) {
            const node = this.startNode.nextSibling;
            value = value === undefined ? '' : value;
            if (node === this.endNode.previousSibling &&
                node.nodeType === Node.TEXT_NODE) {
                // If we only have a single text node between the markers, we can just
                // set its value, rather than replacing it.
                // TODO(justinfagnani): Can we just check if _previousValue is
                // primitive?
                node.textContent = value;
            }
            else {
                this._setNode(document.createTextNode(value));
            }
            this._previousValue = value;
        }
        _setTemplateResult(value) {
            const template = this.instance._getTemplate(value);
            let instance;
            if (this._previousValue && this._previousValue.template === template) {
                instance = this._previousValue;
            }
            else {
                instance = new TemplateInstance(template, this.instance._partCallback, this.instance._getTemplate);
                this._setNode(instance._clone());
                this._previousValue = instance;
            }
            instance.update(value.values);
        }
        _setIterable(value) {
            // For an Iterable, we create a new InstancePart per item, then set its
            // value to the item. This is a little bit of overhead for every item in
            // an Iterable, but it lets us recurse easily and efficiently update Arrays
            // of TemplateResults that will be commonly returned from expressions like:
            // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
            // If _previousValue is an array, then the previous render was of an
            // iterable and _previousValue will contain the NodeParts from the previous
            // render. If _previousValue is not an array, clear this part and make a new
            // array for NodeParts.
            if (!Array.isArray(this._previousValue)) {
                this.clear();
                this._previousValue = [];
            }
            // Lets us keep track of how many items we stamped so we can clear leftover
            // items from a previous render
            const itemParts = this._previousValue;
            let partIndex = 0;
            for (const item of value) {
                // Try to reuse an existing part
                let itemPart = itemParts[partIndex];
                // If no existing part, create a new one
                if (itemPart === undefined) {
                    // If we're creating the first item part, it's startNode should be the
                    // container's startNode
                    let itemStart = this.startNode;
                    // If we're not creating the first part, create a new separator marker
                    // node, and fix up the previous part's endNode to point to it
                    if (partIndex > 0) {
                        const previousPart = itemParts[partIndex - 1];
                        itemStart = previousPart.endNode = document.createTextNode('');
                        this._insert(itemStart);
                    }
                    itemPart = new NodePart(this.instance, itemStart, this.endNode);
                    itemParts.push(itemPart);
                }
                itemPart.setValue(item);
                partIndex++;
            }
            if (partIndex === 0) {
                this.clear();
                this._previousValue = undefined;
            }
            else if (partIndex < itemParts.length) {
                const lastPart = itemParts[partIndex - 1];
                // Truncate the parts array so _previousValue reflects the current state
                itemParts.length = partIndex;
                this.clear(lastPart.endNode.previousSibling);
                lastPart.endNode = this.endNode;
            }
        }
        _setPromise(value) {
            this._previousValue = value;
            value.then((v) => {
                if (this._previousValue === value) {
                    this.setValue(v);
                }
            });
        }
        clear(startNode = this.startNode) {
            removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
        }
    }
    const defaultPartCallback = (instance, templatePart, node) => {
        if (templatePart.type === 'attribute') {
            return new AttributePart(instance, node, templatePart.name, templatePart.strings);
        }
        else if (templatePart.type === 'node') {
            return new NodePart(instance, node, node.nextSibling);
        }
        throw new Error(`Unknown part type ${templatePart.type}`);
    };
    /**
     * An instance of a `Template` that can be attached to the DOM and updated
     * with new values.
     */
    class TemplateInstance {
        constructor(template, partCallback, getTemplate) {
            this._parts = [];
            this.template = template;
            this._partCallback = partCallback;
            this._getTemplate = getTemplate;
        }
        update(values) {
            let valueIndex = 0;
            for (const part of this._parts) {
                if (!part) {
                    valueIndex++;
                }
                else if (part.size === undefined) {
                    part.setValue(values[valueIndex]);
                    valueIndex++;
                }
                else {
                    part.setValue(values, valueIndex);
                    valueIndex += part.size;
                }
            }
        }
        _clone() {
            // Clone the node, rather than importing it, to keep the fragment in the
            // template's document. This leaves the fragment inert so custom elements
            // won't upgrade until after the main document adopts the node.
            const fragment = this.template.element.content.cloneNode(true);
            const parts = this.template.parts;
            if (parts.length > 0) {
                // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
                // null
                const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |
                       NodeFilter.SHOW_TEXT */, null, false);
                let index = -1;
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    const partActive = isTemplatePartActive(part);
                    // An inactive part has no coresponding Template node.
                    if (partActive) {
                        while (index < part.index) {
                            index++;
                            walker.nextNode();
                        }
                    }
                    this._parts.push(partActive ? this._partCallback(this, part, walker.currentNode) : undefined);
                }
            }
            return fragment;
        }
    }
    /**
     * Reparents nodes, starting from `startNode` (inclusive) to `endNode`
     * (exclusive), into another container (could be the same container), before
     * `beforeNode`. If `beforeNode` is null, it appends the nodes to the
     * container.
     */
    const reparentNodes = (container, start, end = null, before = null) => {
        let node = start;
        while (node !== end) {
            const n = node.nextSibling;
            container.insertBefore(node, before);
            node = n;
        }
    };
    /**
     * Removes nodes, starting from `startNode` (inclusive) to `endNode`
     * (exclusive), from `container`.
     */
    const removeNodes = (container, startNode, endNode = null) => {
        let node = startNode;
        while (node !== endNode) {
            const n = node.nextSibling;
            container.removeChild(node);
            node = n;
        }
    };

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * Interprets a template literal as a lit-extended HTML template.
     */
    const html$1 = (strings, ...values) => new TemplateResult(strings, values, 'html', extendedPartCallback);
    /**
     * A PartCallback which allows templates to set properties and declarative
     * event handlers.
     *
     * Properties are set by default, instead of attributes. Attribute names in
     * lit-html templates preserve case, so properties are case sensitive. If an
     * expression takes up an entire attribute value, then the property is set to
     * that value. If an expression is interpolated with a string or other
     * expressions then the property is set to the string result of the
     * interpolation.
     *
     * To set an attribute instead of a property, append a `$` suffix to the
     * attribute name.
     *
     * Example:
     *
     *     html`<button class$="primary">Buy Now</button>`
     *
     * To set an event handler, prefix the attribute name with `on-`:
     *
     * Example:
     *
     *     html`<button on-click=${(e)=> this.onClickHandler(e)}>Buy Now</button>`
     *
     */
    const extendedPartCallback = (instance, templatePart, node) => {
        if (templatePart.type === 'attribute') {
            if (templatePart.rawName.substr(0, 3) === 'on-') {
                const eventName = templatePart.rawName.slice(3);
                return new EventPart(instance, node, eventName);
            }
            const lastChar = templatePart.name.substr(templatePart.name.length - 1);
            if (lastChar === '$') {
                const name = templatePart.name.slice(0, -1);
                return new AttributePart(instance, node, name, templatePart.strings);
            }
            if (lastChar === '?') {
                const name = templatePart.name.slice(0, -1);
                return new BooleanAttributePart(instance, node, name, templatePart.strings);
            }
            return new PropertyPart(instance, node, templatePart.rawName, templatePart.strings);
        }
        return defaultPartCallback(instance, templatePart, node);
    };
    /**
     * Implements a boolean attribute, roughly as defined in the HTML
     * specification.
     *
     * If the value is truthy, then the attribute is present with a value of
     * ''. If the value is falsey, the attribute is removed.
     */
    class BooleanAttributePart extends AttributePart {
        setValue(values, startIndex) {
            const s = this.strings;
            if (s.length === 2 && s[0] === '' && s[1] === '') {
                const value = getValue(this, values[startIndex]);
                if (value === noChange) {
                    return;
                }
                if (value) {
                    this.element.setAttribute(this.name, '');
                }
                else {
                    this.element.removeAttribute(this.name);
                }
            }
            else {
                throw new Error('boolean attributes can only contain a single expression');
            }
        }
    }
    class PropertyPart extends AttributePart {
        setValue(values, startIndex) {
            const s = this.strings;
            let value;
            if (this._equalToPreviousValues(values, startIndex)) {
                return;
            }
            if (s.length === 2 && s[0] === '' && s[1] === '') {
                // An expression that occupies the whole attribute value will leave
                // leading and trailing empty strings.
                value = getValue(this, values[startIndex]);
            }
            else {
                // Interpolation, so interpolate
                value = this._interpolate(values, startIndex);
            }
            if (value !== noChange) {
                this.element[this.name] = value;
            }
            this._previousValues = values;
        }
    }
    class EventPart {
        constructor(instance, element, eventName) {
            this.instance = instance;
            this.element = element;
            this.eventName = eventName;
        }
        setValue(value) {
            const listener = getValue(this, value);
            if (listener === this._listener) {
                return;
            }
            if (listener == null) {
                this.element.removeEventListener(this.eventName, this);
            }
            else if (this._listener == null) {
                this.element.addEventListener(this.eventName, this);
            }
            this._listener = listener;
        }
        handleEvent(event) {
            if (typeof this._listener === 'function') {
                this._listener.call(this.element, event);
            }
            else if (typeof this._listener.handleEvent === 'function') {
                this._listener.handleEvent(event);
            }
        }
    }

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const keyMapCache = new WeakMap();
    function cleanMap(part, key, map) {
        if (!part.startNode.parentNode) {
            map.delete(key);
        }
    }
    function repeat(items, keyFnOrTemplate, template) {
        let keyFn;
        if (arguments.length === 2) {
            template = keyFnOrTemplate;
        }
        else if (arguments.length === 3) {
            keyFn = keyFnOrTemplate;
        }
        return directive((part) => {
            let keyMap = keyMapCache.get(part);
            if (keyMap === undefined) {
                keyMap = new Map();
                keyMapCache.set(part, keyMap);
            }
            const container = part.startNode.parentNode;
            let index = -1;
            let currentMarker = part.startNode.nextSibling;
            for (const item of items) {
                let result;
                let key;
                try {
                    ++index;
                    result = template(item, index);
                    key = keyFn ? keyFn(item) : index;
                }
                catch (e) {
                    console.error(e);
                    continue;
                }
                // Try to reuse a part
                let itemPart = keyMap.get(key);
                if (itemPart === undefined) {
                    const marker = document.createTextNode('');
                    const endNode = document.createTextNode('');
                    container.insertBefore(marker, currentMarker);
                    container.insertBefore(endNode, currentMarker);
                    itemPart = new NodePart(part.instance, marker, endNode);
                    if (key !== undefined) {
                        keyMap.set(key, itemPart);
                    }
                }
                else if (currentMarker !== itemPart.startNode) {
                    // Existing part in the wrong position
                    const end = itemPart.endNode.nextSibling;
                    if (currentMarker !== end) {
                        reparentNodes(container, itemPart.startNode, end, currentMarker);
                    }
                }
                else {
                    // else part is in the correct position already
                    currentMarker = itemPart.endNode.nextSibling;
                }
                itemPart.setValue(result);
            }
            // Cleanup
            if (currentMarker !== part.endNode) {
                removeNodes(container, currentMarker, part.endNode);
                keyMap.forEach(cleanMap);
            }
        });
    }

    class ZcuiWcSearchWidget extends HTMLElement {
      static get observedAttributes() {
        return [];
      }

      constructor() {
        super();
        this.updateShadowDom = this.updateShadowDom.bind(this);
        this.changeCity = this.changeCity.bind(this);
        this.changeDate = this.changeDate.bind(this);
        this.changeMonth = this.changeMonth.bind(this);
        this.changeTime = this.changeTime.bind(this);
        this.searchCar = this.searchCar.bind(this);
        this._validateParams = this._validateParams.bind(this);
        this.filterLocations = this.filterLocations.bind(this);
        this.changeLocation = this.changeLocation.bind(this);
        this.closeLocationList = this.closeLocationList.bind(this);
        
        this.cities = [];
        this._loadXMLDoc({
          method: 'GET',
          url: 'https://api.zoomcar.com/v4/cities',
          data: {
            platform: 'web'
          }
        }, (err, data) => {
          if (data) {
            this.cities = JSON.parse(data).cities.sort((a, b) => {
              const nameA = a.name.toLowerCase(), nameB = b.name.toLowerCase();
              if (nameA < nameB) //sort string ascending
                return -1
              if (nameA > nameB)
                return 1
              return 0 //default return value (no sorting)
            });
          }
          if (err) this.apiErrorMsg = JSON.parse(err).msg;
          this.updateShadowDom();
        });

        this.locations = {};
        this.filteredLocation = [];

        const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        const today = new Date();
        this.monthsYears = Array.apply(null, { length: 6 }).map((x, i) => {
          const d = new Date(today.getFullYear(), today.getMonth() + i, 1);
          return {
            month: d.getMonth()+1,
            year: d.getFullYear(),
            displayName: `${monthNames[d.getMonth()]}'${d.getFullYear().toString().substr(2)}`
          };
        });

        this.timeList = Array.apply(null, { length: 48 }).map((x, i) => {
          let temp = i;
          let ampm = 'AM';
          if (i >= 24) {
            temp = i - 24;
            ampm = 'PM';
          }
          return temp % 2 ? `${(temp + 1) / 2}:30 ${ampm}` : `${temp / 2 + 1}:00 ${ampm}`;
        });

        const tomorrow = new Date(today.getTime() + (60 * 60 * 1000));
        const nextDayTomorrow = new Date(tomorrow.getTime() + (24 * 60 * 60 * 1000));
        //default values
        this.searchParams = {
          starts: {
            date: tomorrow.getDate(),
            monthYearIndex: tomorrow.getMonth() > today.getMonth() ? 1 : 0,
            time: this._get12HrTime(tomorrow)
          },
          ends: {
            date: nextDayTomorrow.getDate(),
            monthYearIndex: nextDayTomorrow.getMonth() > tomorrow.getMonth() ? 1 : 0,
            time: this._get12HrTime(nextDayTomorrow)
          },
          cityLinkName: 'mumbai',
          cityName: 'Mumbai'

        };
        this._updateLocations();

        // index 0 means no error
        this.errorMessages = [
          '',
          'Please select city',
          'Please select starting point',
          'Please select start date',
          'Please select start month',
          'Please select start time',
          'Please select end date',
          'Please select end month',
          'Please select end time',
          'Starts Can\'t be in past',
          'ends Can\'t be in past',
          'Wrong start date selected',
          'Wrong end date selected',
          'Start date cannot be greater than end date'
        ];
        this.pickupErrors = [1,2];
        this.startsErrors = [3,4,5,9,11,13];
        this.endsErrors = [6,7,8,10,12,13];
      }

      get htmlTemplate() {
        return html$1`
      <style>
        .zcui-wc-search-widget{display:flex;padding:20px;font-size:16px;flex-direction:column;font-family:Arial, Helvetica, sans-serif;background-image:url("https://s3.ap-south-1.amazonaws.com/zcui-web-components/images/bg.svg");background-size:contain;margin:auto;text-align:left;min-height:333px}.zcui-wc-search-widget .error{color:#d0021b;text-align:center;margin:10px}.zcui-wc-search-widget header{display:flex;margin:0 auto}.zcui-wc-search-widget header .logo-container{padding:0 20px;margin:10px 0;border-right:solid 1px #cecece}.zcui-wc-search-widget header .logo{width:127px}.zcui-wc-search-widget header .title{padding:10px 20px;width:125px}.zcui-wc-search-widget label{letter-spacing:.5px;margin:0 10px}.zcui-wc-search-widget .search-input{display:flex;flex-wrap:wrap;padding:10px 0}.zcui-wc-search-widget .search-input .input-box{border:solid 1px #8ABD50;margin:7px 10px 20px;display:flex;color:#595656;background:#fff;letter-spacing:.5px}.zcui-wc-search-widget .search-input .input-box.error-border{border-color:#d0021b}.zcui-wc-search-widget .search-input .input-box.button{border:none}.zcui-wc-search-widget .search-input .input-box .city{flex:1;border-right:solid 1px #8ABD50}.zcui-wc-search-widget .search-input .input-box .city span{flex:1}.zcui-wc-search-widget .search-input .input-box .area{flex:2;position:relative}.zcui-wc-search-widget .search-input .input-box .area input{width:100%;border:none;outline:none;font-size:16px;padding:0 10px}.zcui-wc-search-widget .search-input .input-box .area .location-list{box-shadow:0 2px 4px 0 rgba(0,0,0,0.5);height:230px;overflow:scroll;position:absolute;top:45px;width:100%;left:0;background:#fff;border:solid 1px #cecece;z-index:9}.zcui-wc-search-widget .search-input .input-box .area .location-list div{border-bottom:solid 1px #cecece;padding:15px;cursor:pointer}.zcui-wc-search-widget .search-input .input-box .date{width:21%}.zcui-wc-search-widget .search-input .input-box .month{width:45%;border-right:solid 1px #8ABD50;border-left:solid 1px #8ABD50}.zcui-wc-search-widget .search-input .input-box .time{width:34%}.zcui-wc-search-widget .search-input .input-box select{opacity:0;position:absolute;top:0;left:0;bottom:0;right:0;width:100%;height:100%}.zcui-wc-search-widget .search-input .input-box .input{position:relative;padding:12px 9px;display:flex;align-items:center;justify-content:space-between}.zcui-wc-search-widget .search-input .input-wrapper{display:flex;flex-direction:column;flex:1}.zcui-wc-search-widget .date-time{display:flex;flex-wrap:wrap;justify-content:space-between;flex:2}.zcui-wc-search-widget .date-time .input-wrapper{min-width:256px}.zcui-wc-search-widget button{font-size:16px;padding:11px;max-width:420px;border-radius:2.2px;background-color:#6fbe45;box-shadow:1px 1px 7px 0 rgba(186,185,185,0.5);color:#fff;text-transform:uppercase;margin:auto;outline:none}.zcui-wc-search-widget .hide{display:none}

      </style>
      <div class="zcui-wc-search-widget" on-click=${this.closeLocationList}>
  <header>
    <div class="logo-container">
      <img alt="logo" src="https://s3.ap-south-1.amazonaws.com/zcui-web-components/images/logo.svg" class="logo"/>
    </div>
    <i class="title">
       Enjoy Self Drive Cars Starting <b>Rs 60/Hr*</b>
    </i>
    
  </header>
  <div class="error">${this.errorMessages[this.selectedErrorMessage]}</div>
  <div class="error">${this.apiErrorMsg}</div>
  <div class="search-input">
    <div class="input-wrapper">
      <label>Pick-up & Drop-off location</label>
      <div class$="${this.pickupErrors.includes(this.selectedErrorMessage) ? 'input-box error-border' : 'input-box'}">
        <div class="input city">
          <span>
            ${this.searchParams.cityName ? this.searchParams.cityName : 'Select City'}
          </span>
          <img src="https://s3.ap-south-1.amazonaws.com/zcui-web-components/images/arrow.svg" alt="">
          <select on-change=${this.changeCity}>
            <option>${this.cities.length ? '' : 'Please wait'}</option>
             ${repeat( this.cities,
              city => html$1`
              <option selected="${city.link_name==this.searchParams.cityLinkName ? 'selected' : ''}" value="${city.link_name}">${city.name}</option>
            ` )}
          </select>
        </div>
        <div class="input area">
          <img src="https://s3.ap-south-1.amazonaws.com/zcui-web-components/images/location.svg" alt="">
          <input class="area-text-input" type="text" placeholder="Area" on-click=${this.filterLocations} on-keyup=${this.filterLocations} value=${this.searchParams.locationName}>
          <div class$="${this.filteredLocation.length ? 'location-list' : 'hide'}">
            ${repeat(this.filteredLocation, loc => html$1`
              <div on-click=${e => {this.changeLocation(loc);}}>${loc.name}</div>
            `)}
          </div>
        </div>
      </div>
    </div>
    <div class="date-time">

      <div class="input-wrapper">
        <label>Start Date & Time</label>
        <div class$="${this.startsErrors.includes(this.selectedErrorMessage) ? 'input-box error-border' : 'input-box'}">
          <div class="input date">
            <span>${this.searchParams.starts.date ? this.searchParams.starts.date : 'Date'}</span>
            <img src="https://s3.ap-south-1.amazonaws.com/zcui-web-components/images/arrow.svg" alt="">
            <select on-change=${e => { this.changeDate(e.currentTarget.value, 'starts');}}>
              ${repeat( Array.apply(null, {length: 31}).map((x,i)=> i+1), day => html$1`
              <option value="${day}" selected="${day==this.searchParams.starts.date ? 'selected' : '' }">${day}</option>
              ` )}
            </select>
          </div>
          <div class="input month">
            <span>
              ${this.searchParams.starts.monthYearIndex || this.searchParams.starts.monthYearIndex==0 ?
                this.monthsYears[this.searchParams.starts.monthYearIndex].displayName :
                'Month'
              }
            </span>
            <img src="https://s3.ap-south-1.amazonaws.com/zcui-web-components/images/arrow.svg" alt="">
            <select on-change=${e => { this.changeMonth(e.currentTarget.value, 'starts');}}>
              ${repeat(this.monthsYears, (month, i) => html$1`
              <option selected="${i==this.searchParams.starts.monthYearIndex ? 'selected' : ''}" value=${i}>${month.displayName}</option>
              `)}
            </select>
          </div>
          <div class="input time">
            <span>${this.searchParams.starts.time ? this.searchParams.starts.time : 'Time'}</span>
            <img src="https://s3.ap-south-1.amazonaws.com/zcui-web-components/images/arrow.svg" alt="">
            <select on-change=${e => { this.changeTime(e.currentTarget.value, 'starts');}}>
              ${repeat(this.timeList, time => html$1 `
              <option selected="${ time==this.searchParams.starts.time ? 'selected' : '' }" value=${time}>${time}</option>
              `)}
            </select>
          </div>
        </div>
      </div>

      <div class="input-wrapper">
        <label>End Date & Time</label>
        <div class$="${this.endsErrors.includes(this.selectedErrorMessage) ? 'input-box error-border' : 'input-box'}">
          <div class="input date">
            <span>${this.searchParams.ends.date ? this.searchParams.ends.date : 'Date'}</span>
            <img src="https://s3.ap-south-1.amazonaws.com/zcui-web-components/images/arrow.svg" alt="">
            <select on-change=${e => { this.changeDate(e.currentTarget.value, 'ends');}}>
              ${repeat( Array.apply(null, {length: 31}).map((x,i)=> i+1), day => html$1`
              <option selected="${day==this.searchParams.ends.date ? 'selected' : '' }" value="${day}">${day}</option>
              ` )}
            </select>
          </div>
          <div class="input month">
            <span>
              ${this.searchParams.ends.monthYearIndex || this.searchParams.ends.monthYearIndex==0 ? this.monthsYears[this.searchParams.ends.monthYearIndex].displayName :
                'Month' }
            </span>
            <img src="https://s3.ap-south-1.amazonaws.com/zcui-web-components/images/arrow.svg" alt="">
            <select on-change=${e => { this.changeMonth(e.currentTarget.value, 'ends');}}>
              ${repeat(this.monthsYears, (month, i) => html$1`
              <option selected="${i==this.searchParams.ends.monthYearIndex ? 'selected' : ''}" value=${i}>${month.displayName}</option>
              `)}
            </select>
          </div>
          <div class="input time">
            <span>${this.searchParams.ends.time ? this.searchParams.ends.time : 'Time'}</span>
            <img src="https://s3.ap-south-1.amazonaws.com/zcui-web-components/images/arrow.svg" alt="">
            <select on-change=${e => { this.changeTime(e.currentTarget.value, 'ends');}}>
              ${repeat(this.timeList, time => html$1 `
              <option selected="${ time==this.searchParams.ends.time ? 'selected' : '' }" value=${time}>${time}</option>
              `)}
            </select>
          </div>
        </div>
      </div>
    </div>
    <div>
      <label for=""></label>
      <div class="input-box button"><button on-click=${this.searchCar}> Search Car</button></div>
    </div>
    
  </div>
</div>
    `;
      }


      createShadowDom() {
        this.attachShadow({ mode: 'open' });
        this.updateShadowDom();
      }

      updateShadowDom() {
        if (this.shadowRoot) {
          render(this.htmlTemplate, this.shadowRoot);
        }
      }

      attributeChangedCallback(attr, oldVal, newVal) {
        if (oldVal != newVal) {
          this.setProps();
          this.updateShadowDom();
        }
      }

      connectedCallback() {
        Reflect.construct(HTMLElement, [], this.constructor);
        this.createShadowDom();
      }

      _updateLocations() {
        if (this.locations[this.searchParams.cityLinkName]) return;
        this._loadXMLDoc({
          method: 'GET',
          url: 'https://api.zoomcar.com/v4/hubs',
          data: {
            platform: 'web',
            city: this.searchParams.cityLinkName
          }
        }, (err, data) => {
          if (data) {
            const hubs = JSON.parse(data).hubs.sort((a, b) => {
              const nameA = a.name.toLowerCase(), nameB = b.name.toLowerCase();
              if (nameA < nameB) //sort string ascending
                return -1
              if (nameA > nameB)
                return 1
              return 0 //default return value (no sorting)
            });
            this.locations[this.searchParams.cityLinkName] = hubs;
          }
          if (err) this.apiErrorMsg = JSON.parse(err).msg;
          this.updateShadowDom();
        });
      }

      changeCity(e) {
        this.searchParams.cityLinkName = e.target.value;
        this.searchParams.cityName = this.cities.filter(city => city.link_name == e.target.value)[0].name;
        delete this.searchParams.lat;
        delete this.searchParams.lng;
        this._updateLocations();
        this.searchParams.locationName = '';
        this.updateShadowDom();
      }

      changeDate(val, type) {
        this.searchParams[type].date = val;
        this.updateShadowDom();
      }

      changeMonth(val, type) {
        this.searchParams[type].monthYearIndex = val;
        this.updateShadowDom();
      }

      changeTime(val, type) {
        this.searchParams[type].time = val;
        this.updateShadowDom();
      }

      filterLocations(e) {
        if (!this.searchParams.cityLinkName) return;
        this.filteredLocation = this.locations[this.searchParams.cityLinkName].filter(loc => {
          return loc.name.toLowerCase().includes(e.currentTarget.value.toLowerCase());
        });
        this.updateShadowDom();
      }

      changeLocation(loc) {
        this.searchParams.locationName = loc.name;
        this.searchParams.lat = loc.lat;
        this.searchParams.lng = loc.lng;
        this.filteredLocation = [];
        this.updateShadowDom();
      }

      daysInMonth(type) {
        const monthYearIndex = this.searchParams[type].monthYearIndex;
        const selectMonthYear = this.monthsYears[monthYearIndex];
        return new Date(selectMonthYear.year, selectMonthYear.month, 0).getDate();
      }

      _get24HrTime(time) {
        const timeArr = time.split(' ');
        return timeArr[1] == 'PM' ? `${parseInt(timeArr[0].split(':')[0]) + 12}:${timeArr[0].split(':')[1]}` : timeArr[0];
      }

      _dateInPast(type) {
        const monthYearIndex = this.searchParams[type].monthYearIndex;
        const selectMonthYear = this.monthsYears[monthYearIndex];
        const date = new Date(`${selectMonthYear.month}-${this.searchParams[type].date}-${selectMonthYear.year} ${this.searchParams[type].time}`);
        const today = new Date();
        return today > date;
      }

      _isStartsGreaterPast() {
        const startsMonthYearIndex = this.searchParams.starts.monthYearIndex;
        const selectStartsMonthYear = this.monthsYears[startsMonthYearIndex];
        const endsMonthYearIndex = this.searchParams.ends.monthYearIndex;
        const selectEndsMonthYear = this.monthsYears[endsMonthYearIndex];
        const starts = new Date(`${selectStartsMonthYear.month}-${this.searchParams.starts.date}-${selectStartsMonthYear.year} ${this.searchParams.starts.time}`);
        const ends = new Date(`${selectEndsMonthYear.month}-${this.searchParams.ends.date}-${selectEndsMonthYear.year} ${this.searchParams.ends.time}`);
        return starts > ends;
      }
      _validateParams() {
        const params = this.searchParams;
        if (!params.cityLinkName) return 1;
        if (!params.lat || !params.lng) return 2;
        if (!params.starts.date) return 3;
        if (!params.starts.monthYearIndex && params.starts.monthYearIndex!=0) return 4;
        if (!params.starts.time) return 5;
        if (!params.ends.date) return 6;
        if (!params.ends.monthYearIndex && params.ends.monthYearIndex != 0) return 7;
        if (!params.ends.time) return 8;
        if (this._dateInPast('starts')) return 9;
        if (this._dateInPast('ends')) return 10;
        if (parseInt(params.starts.date) > this.daysInMonth('starts')) return 11;
        if (parseInt(params.ends.date) > this.daysInMonth('ends')) return 12;
        if (this._isStartsGreaterPast()) return 13;
      }

      searchCar() {
        this.selectedErrorMessage = this._validateParams();
        this.updateShadowDom();
        if (this.selectedErrorMessage) return;
        const startsMonthYearIndex = this.searchParams.starts.monthYearIndex;
        const selectStartsMonthYear = this.monthsYears[startsMonthYearIndex];
        const endsMonthYearIndex = this.searchParams.ends.monthYearIndex;
        const selectEndsMonthYear = this.monthsYears[endsMonthYearIndex];
        const url = `https://www.zoomcar.com/${this.searchParams.cityLinkName}/search/query?lat=${this.searchParams.lat}&lng=${this.searchParams.lng}&starts=${selectStartsMonthYear.year}-${selectStartsMonthYear.month}-${this.searchParams.starts.date} ${this._get24HrTime(this.searchParams.starts.time)}&ends=${selectEndsMonthYear.year}-${selectEndsMonthYear.month}-${this.searchParams.ends.date} ${window.encodeURIComponent(this._get24HrTime(this.searchParams.ends.time))}&type=zoom_later&bracket=with_fuel&ref=${window.location.hostname}`;
        window.open(url, '_blank');
      }

      _loadXMLDoc(request, callback) {
        const { url, method = 'GET', data = {} } = request;
        const urlParams = this._objToUrl(data);
        let xmlhttp;
        if (window.XMLHttpRequest) {
          xmlhttp = new XMLHttpRequest();
        } else {
          xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
        }
        xmlhttp.onreadystatechange = function () {
          if (this.readyState == 4) {
            if (this.status == 200) {
              callback(null, this.responseText);
            } else {
              callback(this.responseText, null);
            }
          }
        };
        xmlhttp.open(method, `${request.url}?${urlParams}`, true);
        xmlhttp.send(method == 'POST' ? urlParams : undefined);
      }
      
      _objToUrl(obj) {
        return Object.keys(obj).map(k => `${k}=${obj[k]}`).join('&');
      }

      closeLocationList(e) {
        if (e.target.className == 'area-text-input') return;
        this.filteredLocation = [];
        this.updateShadowDom();
      }
      _get12HrTime(date) {
        return date.getHours() > 12 ? `${date.getHours() - 12}:00 PM` : `${date.getHours()}:00 AM`;
      }
    }

      window.customElements.define('zcui-wc-search-widget', ZcuiWcSearchWidget);

}());
