(function () {
  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  var taggedTemplateLiteral = function (strings, raw) {
    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  };

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  // The first argument to JS template tags retain identity across multiple
  // calls to a tag for the same literal, so we can cache work done per literal
  // in a Map.
  var templateCaches = new Map();
  /**
   * The return type of `html`, which holds a Template and the values from
   * interpolated expressions.
   */
  var TemplateResult = function () {
      function TemplateResult(strings, values, type) {
          var partCallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultPartCallback;
          classCallCheck(this, TemplateResult);

          this.strings = strings;
          this.values = values;
          this.type = type;
          this.partCallback = partCallback;
      }
      /**
       * Returns a string of HTML used to create a <template> element.
       */


      createClass(TemplateResult, [{
          key: 'getHTML',
          value: function getHTML() {
              var l = this.strings.length - 1;
              var html = '';
              var isTextBinding = true;
              for (var i = 0; i < l; i++) {
                  var s = this.strings[i];
                  html += s;
                  // We're in a text position if the previous string closed its tags.
                  // If it doesn't have any tags, then we use the previous text position
                  // state.
                  var closing = findTagClose(s);
                  isTextBinding = closing > -1 ? closing < s.length : isTextBinding;
                  html += isTextBinding ? nodeMarker : marker;
              }
              html += this.strings[l];
              return html;
          }
      }, {
          key: 'getTemplateElement',
          value: function getTemplateElement() {
              var template = document.createElement('template');
              template.innerHTML = this.getHTML();
              return template;
          }
      }]);
      return TemplateResult;
  }();
  /**
   * A TemplateResult for SVG fragments.
   *
   * This class wraps HTMl in an <svg> tag in order to parse its contents in the
   * SVG namespace, then modifies the template to remove the <svg> tag so that
   * clones only container the original fragment.
   */
  var SVGTemplateResult = function (_TemplateResult) {
      inherits(SVGTemplateResult, _TemplateResult);

      function SVGTemplateResult() {
          classCallCheck(this, SVGTemplateResult);
          return possibleConstructorReturn(this, (SVGTemplateResult.__proto__ || Object.getPrototypeOf(SVGTemplateResult)).apply(this, arguments));
      }

      createClass(SVGTemplateResult, [{
          key: 'getHTML',
          value: function getHTML() {
              return '<svg>' + get(SVGTemplateResult.prototype.__proto__ || Object.getPrototypeOf(SVGTemplateResult.prototype), 'getHTML', this).call(this) + '</svg>';
          }
      }, {
          key: 'getTemplateElement',
          value: function getTemplateElement() {
              var template = get(SVGTemplateResult.prototype.__proto__ || Object.getPrototypeOf(SVGTemplateResult.prototype), 'getTemplateElement', this).call(this);
              var content = template.content;
              var svgElement = content.firstChild;
              content.removeChild(svgElement);
              reparentNodes(content, svgElement.firstChild);
              return template;
          }
      }]);
      return SVGTemplateResult;
  }(TemplateResult);
  /**
   * The default TemplateFactory which caches Templates keyed on
   * result.type and result.strings.
   */
  function defaultTemplateFactory(result) {
      var templateCache = templateCaches.get(result.type);
      if (templateCache === undefined) {
          templateCache = new Map();
          templateCaches.set(result.type, templateCache);
      }
      var template = templateCache.get(result.strings);
      if (template === undefined) {
          template = new Template(result, result.getTemplateElement());
          templateCache.set(result.strings, template);
      }
      return template;
  }
  /**
   * Renders a template to a container.
   *
   * To update a container with new values, reevaluate the template literal and
   * call `render` with the new result.
   *
   * @param result a TemplateResult created by evaluating a template tag like
   *     `html` or `svg`.
   * @param container A DOM parent to render to. The entire contents are either
   *     replaced, or efficiently updated if the same result type was previous
   *     rendered there.
   * @param templateFactory a function to create a Template or retreive one from
   *     cache.
   */
  function render(result, container) {
      var templateFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultTemplateFactory;

      var template = templateFactory(result);
      var instance = container.__templateInstance;
      // Repeat render, just call update()
      if (instance !== undefined && instance.template === template && instance._partCallback === result.partCallback) {
          instance.update(result.values);
          return;
      }
      // First render, create a new TemplateInstance and append it
      instance = new TemplateInstance(template, result.partCallback, templateFactory);
      container.__templateInstance = instance;
      var fragment = instance._clone();
      instance.update(result.values);
      removeNodes(container, container.firstChild);
      container.appendChild(fragment);
  }
  /**
   * An expression marker with embedded unique key to avoid collision with
   * possible text in templates.
   */
  var marker = '{{lit-' + String(Math.random()).slice(2) + '}}';
  /**
   * An expression marker used text-positions, not attribute positions,
   * in template.
   */
  var nodeMarker = '<!--' + marker + '-->';
  var markerRegex = new RegExp(marker + '|' + nodeMarker);
  /**
   * This regex extracts the attribute name preceding an attribute-position
   * expression. It does this by matching the syntax allowed for attributes
   * against the string literal directly preceding the expression, assuming that
   * the expression is in an attribute-value position.
   *
   * See attributes in the HTML spec:
   * https://www.w3.org/TR/html5/syntax.html#attributes-0
   *
   * "\0-\x1F\x7F-\x9F" are Unicode control characters
   *
   * " \x09\x0a\x0c\x0d" are HTML space characters:
   * https://www.w3.org/TR/html5/infrastructure.html#space-character
   *
   * So an attribute is:
   *  * The name: any character except a control character, space character, ('),
   *    ("), ">", "=", or "/"
   *  * Followed by zero or more space characters
   *  * Followed by "="
   *  * Followed by zero or more space characters
   *  * Followed by:
   *    * Any character except space, ('), ("), "<", ">", "=", (`), or
   *    * (") then any non-("), or
   *    * (') then any non-(')
   */
  var lastAttributeNameRegex = /[ \x09\x0a\x0c\x0d]([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)[ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*)$/;
  /**
   * Finds the closing index of the last closed HTML tag.
   * This has 3 possible return values:
   *   - `-1`, meaning there is no tag in str.
   *   - `string.length`, meaning the last opened tag is unclosed.
   *   - Some positive number < str.length, meaning the index of the closing '>'.
   */
  function findTagClose(str) {
      var close = str.lastIndexOf('>');
      var open = str.indexOf('<', close + 1);
      return open > -1 ? str.length : close;
  }
  /**
   * A placeholder for a dynamic expression in an HTML template.
   *
   * There are two built-in part types: AttributePart and NodePart. NodeParts
   * always represent a single dynamic expression, while AttributeParts may
   * represent as many expressions are contained in the attribute.
   *
   * A Template's parts are mutable, so parts can be replaced or modified
   * (possibly to implement different template semantics). The contract is that
   * parts can only be replaced, not removed, added or reordered, and parts must
   * always consume the correct number of values in their `update()` method.
   *
   * TODO(justinfagnani): That requirement is a little fragile. A
   * TemplateInstance could instead be more careful about which values it gives
   * to Part.update().
   */
  var TemplatePart = function TemplatePart(type, index, name, rawName, strings) {
      classCallCheck(this, TemplatePart);

      this.type = type;
      this.index = index;
      this.name = name;
      this.rawName = rawName;
      this.strings = strings;
  };
  var isTemplatePartActive = function isTemplatePartActive(part) {
      return part.index !== -1;
  };
  /**
   * An updateable Template that tracks the location of dynamic parts.
   */
  var Template = function Template(result, element) {
      classCallCheck(this, Template);

      this.parts = [];
      this.element = element;
      var content = this.element.content;
      // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
      var walker = document.createTreeWalker(content, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |
                                                          NodeFilter.SHOW_TEXT */, null, false);
      var index = -1;
      var partIndex = 0;
      var nodesToRemove = [];
      // The actual previous node, accounting for removals: if a node is removed
      // it will never be the previousNode.
      var previousNode = void 0;
      // Used to set previousNode at the top of the loop.
      var currentNode = void 0;
      while (walker.nextNode()) {
          index++;
          previousNode = currentNode;
          var node = currentNode = walker.currentNode;
          if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
                  if (!node.hasAttributes()) {
                      continue;
                  }
                  var attributes = node.attributes;
                  // Per https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
                  // attributes are not guaranteed to be returned in document order. In
                  // particular, Edge/IE can return them out of order, so we cannot assume
                  // a correspondance between part index and attribute index.
                  var count = 0;
                  for (var i = 0; i < attributes.length; i++) {
                      if (attributes[i].value.indexOf(marker) >= 0) {
                          count++;
                      }
                  }
                  while (count-- > 0) {
                      // Get the template literal section leading up to the first
                      // expression in this attribute
                      var stringForPart = result.strings[partIndex];
                      // Find the attribute name
                      var attributeNameInPart = lastAttributeNameRegex.exec(stringForPart)[1];
                      // Find the corresponding attribute
                      // TODO(justinfagnani): remove non-null assertion
                      var attribute = attributes.getNamedItem(attributeNameInPart);
                      var stringsForAttributeValue = attribute.value.split(markerRegex);
                      this.parts.push(new TemplatePart('attribute', index, attribute.name, attributeNameInPart, stringsForAttributeValue));
                      node.removeAttribute(attribute.name);
                      partIndex += stringsForAttributeValue.length - 1;
                  }
              } else if (node.nodeType === 3 /* Node.TEXT_NODE */) {
                  var nodeValue = node.nodeValue;
                  if (nodeValue.indexOf(marker) < 0) {
                      continue;
                  }
                  var parent = node.parentNode;
                  var strings = nodeValue.split(markerRegex);
                  var lastIndex = strings.length - 1;
                  // We have a part for each match found
                  partIndex += lastIndex;
                  // Generate a new text node for each literal section
                  // These nodes are also used as the markers for node parts
                  for (var _i = 0; _i < lastIndex; _i++) {
                      parent.insertBefore(strings[_i] === '' ? document.createComment('') : document.createTextNode(strings[_i]), node);
                      this.parts.push(new TemplatePart('node', index++));
                  }
                  parent.insertBefore(strings[lastIndex] === '' ? document.createComment('') : document.createTextNode(strings[lastIndex]), node);
                  nodesToRemove.push(node);
              } else if (node.nodeType === 8 /* Node.COMMENT_NODE */ && node.nodeValue === marker) {
              var _parent = node.parentNode;
              // Add a new marker node to be the startNode of the Part if any of the
              // following are true:
              //  * We don't have a previousSibling
              //  * previousSibling is being removed (thus it's not the
              //    `previousNode`)
              //  * previousSibling is not a Text node
              //
              // TODO(justinfagnani): We should be able to use the previousNode here
              // as the marker node and reduce the number of extra nodes we add to a
              // template. See https://github.com/PolymerLabs/lit-html/issues/147
              var previousSibling = node.previousSibling;
              if (previousSibling === null || previousSibling !== previousNode || previousSibling.nodeType !== Node.TEXT_NODE) {
                  _parent.insertBefore(document.createComment(''), node);
              } else {
                  index--;
              }
              this.parts.push(new TemplatePart('node', index++));
              nodesToRemove.push(node);
              // If we don't have a nextSibling add a marker node.
              // We don't have to check if the next node is going to be removed,
              // because that node will induce a new marker if so.
              if (node.nextSibling === null) {
                  _parent.insertBefore(document.createComment(''), node);
              } else {
                  index--;
              }
              currentNode = previousNode;
              partIndex++;
          }
      }
      // Remove text binding nodes after the walk to not disturb the TreeWalker
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
          for (var _iterator = nodesToRemove[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var n = _step.value;

              n.parentNode.removeChild(n);
          }
      } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
      } finally {
          try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
              }
          } finally {
              if (_didIteratorError) {
                  throw _iteratorError;
              }
          }
      }
  };
  /**
   * Returns a value ready to be inserted into a Part from a user-provided value.
   *
   * If the user value is a directive, this invokes the directive with the given
   * part. If the value is null, it's converted to undefined to work better
   * with certain DOM APIs, like textContent.
   */
  var getValue = function getValue(part, value) {
      // `null` as the value of a Text node will render the string 'null'
      // so we convert it to undefined
      if (isDirective(value)) {
          value = value(part);
          return noChange;
      }
      return value === null ? undefined : value;
  };
  var directive = function directive(f) {
      f.__litDirective = true;
      return f;
  };
  var isDirective = function isDirective(o) {
      return typeof o === 'function' && o.__litDirective === true;
  };
  /**
   * A sentinel value that signals that a value was handled by a directive and
   * should not be written to the DOM.
   */
  var noChange = {};
  var isPrimitiveValue = function isPrimitiveValue(value) {
      return value === null || !((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' || typeof value === 'function');
  };
  var AttributePart = function () {
      function AttributePart(instance, element, name, strings) {
          classCallCheck(this, AttributePart);

          this.instance = instance;
          this.element = element;
          this.name = name;
          this.strings = strings;
          this.size = strings.length - 1;
          this._previousValues = [];
      }

      createClass(AttributePart, [{
          key: '_interpolate',
          value: function _interpolate(values, startIndex) {
              var strings = this.strings;
              var l = strings.length - 1;
              var text = '';
              for (var i = 0; i < l; i++) {
                  text += strings[i];
                  var v = getValue(this, values[startIndex + i]);
                  if (v && v !== noChange && (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {
                      var _iteratorNormalCompletion2 = true;
                      var _didIteratorError2 = false;
                      var _iteratorError2 = undefined;

                      try {
                          for (var _iterator2 = v[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                              var t = _step2.value;

                              // TODO: we need to recursively call getValue into iterables...
                              text += t;
                          }
                      } catch (err) {
                          _didIteratorError2 = true;
                          _iteratorError2 = err;
                      } finally {
                          try {
                              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                  _iterator2.return();
                              }
                          } finally {
                              if (_didIteratorError2) {
                                  throw _iteratorError2;
                              }
                          }
                      }
                  } else {
                      text += v;
                  }
              }
              return text + strings[l];
          }
      }, {
          key: '_equalToPreviousValues',
          value: function _equalToPreviousValues(values, startIndex) {
              for (var i = startIndex; i < startIndex + this.size; i++) {
                  if (this._previousValues[i] !== values[i] || !isPrimitiveValue(values[i])) {
                      return false;
                  }
              }
              return true;
          }
      }, {
          key: 'setValue',
          value: function setValue(values, startIndex) {
              if (this._equalToPreviousValues(values, startIndex)) {
                  return;
              }
              var s = this.strings;
              var value = void 0;
              if (s.length === 2 && s[0] === '' && s[1] === '') {
                  // An expression that occupies the whole attribute value will leave
                  // leading and trailing empty strings.
                  value = getValue(this, values[startIndex]);
                  if (Array.isArray(value)) {
                      value = value.join('');
                  }
              } else {
                  value = this._interpolate(values, startIndex);
              }
              if (value !== noChange) {
                  this.element.setAttribute(this.name, value);
              }
              this._previousValues = values;
          }
      }]);
      return AttributePart;
  }();
  var NodePart = function () {
      function NodePart(instance, startNode, endNode) {
          classCallCheck(this, NodePart);

          this.instance = instance;
          this.startNode = startNode;
          this.endNode = endNode;
          this._previousValue = undefined;
      }

      createClass(NodePart, [{
          key: 'setValue',
          value: function setValue(value) {
              value = getValue(this, value);
              if (value === noChange) {
                  return;
              }
              if (isPrimitiveValue(value)) {
                  // Handle primitive values
                  // If the value didn't change, do nothing
                  if (value === this._previousValue) {
                      return;
                  }
                  this._setText(value);
              } else if (value instanceof TemplateResult) {
                  this._setTemplateResult(value);
              } else if (Array.isArray(value) || value[Symbol.iterator]) {
                  this._setIterable(value);
              } else if (value instanceof Node) {
                  this._setNode(value);
              } else if (value.then !== undefined) {
                  this._setPromise(value);
              } else {
                  // Fallback, will render the string representation
                  this._setText(value);
              }
          }
      }, {
          key: '_insert',
          value: function _insert(node) {
              this.endNode.parentNode.insertBefore(node, this.endNode);
          }
      }, {
          key: '_setNode',
          value: function _setNode(value) {
              if (this._previousValue === value) {
                  return;
              }
              this.clear();
              this._insert(value);
              this._previousValue = value;
          }
      }, {
          key: '_setText',
          value: function _setText(value) {
              var node = this.startNode.nextSibling;
              value = value === undefined ? '' : value;
              if (node === this.endNode.previousSibling && node.nodeType === Node.TEXT_NODE) {
                  // If we only have a single text node between the markers, we can just
                  // set its value, rather than replacing it.
                  // TODO(justinfagnani): Can we just check if _previousValue is
                  // primitive?
                  node.textContent = value;
              } else {
                  this._setNode(document.createTextNode(value));
              }
              this._previousValue = value;
          }
      }, {
          key: '_setTemplateResult',
          value: function _setTemplateResult(value) {
              var template = this.instance._getTemplate(value);
              var instance = void 0;
              if (this._previousValue && this._previousValue.template === template) {
                  instance = this._previousValue;
              } else {
                  instance = new TemplateInstance(template, this.instance._partCallback, this.instance._getTemplate);
                  this._setNode(instance._clone());
                  this._previousValue = instance;
              }
              instance.update(value.values);
          }
      }, {
          key: '_setIterable',
          value: function _setIterable(value) {
              // For an Iterable, we create a new InstancePart per item, then set its
              // value to the item. This is a little bit of overhead for every item in
              // an Iterable, but it lets us recurse easily and efficiently update Arrays
              // of TemplateResults that will be commonly returned from expressions like:
              // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
              // If _previousValue is an array, then the previous render was of an
              // iterable and _previousValue will contain the NodeParts from the previous
              // render. If _previousValue is not an array, clear this part and make a new
              // array for NodeParts.
              if (!Array.isArray(this._previousValue)) {
                  this.clear();
                  this._previousValue = [];
              }
              // Lets us keep track of how many items we stamped so we can clear leftover
              // items from a previous render
              var itemParts = this._previousValue;
              var partIndex = 0;
              var _iteratorNormalCompletion3 = true;
              var _didIteratorError3 = false;
              var _iteratorError3 = undefined;

              try {
                  for (var _iterator3 = value[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                      var item = _step3.value;

                      // Try to reuse an existing part
                      var itemPart = itemParts[partIndex];
                      // If no existing part, create a new one
                      if (itemPart === undefined) {
                          // If we're creating the first item part, it's startNode should be the
                          // container's startNode
                          var itemStart = this.startNode;
                          // If we're not creating the first part, create a new separator marker
                          // node, and fix up the previous part's endNode to point to it
                          if (partIndex > 0) {
                              var previousPart = itemParts[partIndex - 1];
                              itemStart = previousPart.endNode = document.createTextNode('');
                              this._insert(itemStart);
                          }
                          itemPart = new NodePart(this.instance, itemStart, this.endNode);
                          itemParts.push(itemPart);
                      }
                      itemPart.setValue(item);
                      partIndex++;
                  }
              } catch (err) {
                  _didIteratorError3 = true;
                  _iteratorError3 = err;
              } finally {
                  try {
                      if (!_iteratorNormalCompletion3 && _iterator3.return) {
                          _iterator3.return();
                      }
                  } finally {
                      if (_didIteratorError3) {
                          throw _iteratorError3;
                      }
                  }
              }

              if (partIndex === 0) {
                  this.clear();
                  this._previousValue = undefined;
              } else if (partIndex < itemParts.length) {
                  var lastPart = itemParts[partIndex - 1];
                  // Truncate the parts array so _previousValue reflects the current state
                  itemParts.length = partIndex;
                  this.clear(lastPart.endNode.previousSibling);
                  lastPart.endNode = this.endNode;
              }
          }
      }, {
          key: '_setPromise',
          value: function _setPromise(value) {
              var _this2 = this;

              this._previousValue = value;
              value.then(function (v) {
                  if (_this2._previousValue === value) {
                      _this2.setValue(v);
                  }
              });
          }
      }, {
          key: 'clear',
          value: function clear() {
              var startNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.startNode;

              removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
          }
      }]);
      return NodePart;
  }();
  var defaultPartCallback = function defaultPartCallback(instance, templatePart, node) {
      if (templatePart.type === 'attribute') {
          return new AttributePart(instance, node, templatePart.name, templatePart.strings);
      } else if (templatePart.type === 'node') {
          return new NodePart(instance, node, node.nextSibling);
      }
      throw new Error('Unknown part type ' + templatePart.type);
  };
  /**
   * An instance of a `Template` that can be attached to the DOM and updated
   * with new values.
   */
  var TemplateInstance = function () {
      function TemplateInstance(template, partCallback, getTemplate) {
          classCallCheck(this, TemplateInstance);

          this._parts = [];
          this.template = template;
          this._partCallback = partCallback;
          this._getTemplate = getTemplate;
      }

      createClass(TemplateInstance, [{
          key: 'update',
          value: function update(values) {
              var valueIndex = 0;
              var _iteratorNormalCompletion4 = true;
              var _didIteratorError4 = false;
              var _iteratorError4 = undefined;

              try {
                  for (var _iterator4 = this._parts[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                      var part = _step4.value;

                      if (!part) {
                          valueIndex++;
                      } else if (part.size === undefined) {
                          part.setValue(values[valueIndex]);
                          valueIndex++;
                      } else {
                          part.setValue(values, valueIndex);
                          valueIndex += part.size;
                      }
                  }
              } catch (err) {
                  _didIteratorError4 = true;
                  _iteratorError4 = err;
              } finally {
                  try {
                      if (!_iteratorNormalCompletion4 && _iterator4.return) {
                          _iterator4.return();
                      }
                  } finally {
                      if (_didIteratorError4) {
                          throw _iteratorError4;
                      }
                  }
              }
          }
      }, {
          key: '_clone',
          value: function _clone() {
              // Clone the node, rather than importing it, to keep the fragment in the
              // template's document. This leaves the fragment inert so custom elements
              // won't upgrade until after the main document adopts the node.
              var fragment = this.template.element.content.cloneNode(true);
              var parts = this.template.parts;
              if (parts.length > 0) {
                  // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
                  // null
                  var _walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |
                                                                        NodeFilter.SHOW_TEXT */, null, false);
                  var _index = -1;
                  for (var i = 0; i < parts.length; i++) {
                      var part = parts[i];
                      var partActive = isTemplatePartActive(part);
                      // An inactive part has no coresponding Template node.
                      if (partActive) {
                          while (_index < part.index) {
                              _index++;
                              _walker.nextNode();
                          }
                      }
                      this._parts.push(partActive ? this._partCallback(this, part, _walker.currentNode) : undefined);
                  }
              }
              return fragment;
          }
      }]);
      return TemplateInstance;
  }();
  /**
   * Reparents nodes, starting from `startNode` (inclusive) to `endNode`
   * (exclusive), into another container (could be the same container), before
   * `beforeNode`. If `beforeNode` is null, it appends the nodes to the
   * container.
   */
  var reparentNodes = function reparentNodes(container, start) {
      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var before = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var node = start;
      while (node !== end) {
          var n = node.nextSibling;
          container.insertBefore(node, before);
          node = n;
      }
  };
  /**
   * Removes nodes, starting from `startNode` (inclusive) to `endNode`
   * (exclusive), from `container`.
   */
  var removeNodes = function removeNodes(container, startNode) {
      var endNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var node = startNode;
      while (node !== endNode) {
          var n = node.nextSibling;
          container.removeChild(node);
          node = n;
      }
  };

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  /**
   * Interprets a template literal as a lit-extended HTML template.
   */
  var html$1 = function html$$1(strings) {
      for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          values[_key - 1] = arguments[_key];
      }

      return new TemplateResult(strings, values, 'html', extendedPartCallback);
  };
  /**
   * A PartCallback which allows templates to set properties and declarative
   * event handlers.
   *
   * Properties are set by default, instead of attributes. Attribute names in
   * lit-html templates preserve case, so properties are case sensitive. If an
   * expression takes up an entire attribute value, then the property is set to
   * that value. If an expression is interpolated with a string or other
   * expressions then the property is set to the string result of the
   * interpolation.
   *
   * To set an attribute instead of a property, append a `$` suffix to the
   * attribute name.
   *
   * Example:
   *
   *     html`<button class$="primary">Buy Now</button>`
   *
   * To set an event handler, prefix the attribute name with `on-`:
   *
   * Example:
   *
   *     html`<button on-click=${(e)=> this.onClickHandler(e)}>Buy Now</button>`
   *
   */
  var extendedPartCallback = function extendedPartCallback(instance, templatePart, node) {
      if (templatePart.type === 'attribute') {
          if (templatePart.rawName.substr(0, 3) === 'on-') {
              var eventName = templatePart.rawName.slice(3);
              return new EventPart(instance, node, eventName);
          }
          var lastChar = templatePart.name.substr(templatePart.name.length - 1);
          if (lastChar === '$') {
              var name = templatePart.name.slice(0, -1);
              return new AttributePart(instance, node, name, templatePart.strings);
          }
          if (lastChar === '?') {
              var _name = templatePart.name.slice(0, -1);
              return new BooleanAttributePart(instance, node, _name, templatePart.strings);
          }
          return new PropertyPart(instance, node, templatePart.rawName, templatePart.strings);
      }
      return defaultPartCallback(instance, templatePart, node);
  };
  /**
   * Implements a boolean attribute, roughly as defined in the HTML
   * specification.
   *
   * If the value is truthy, then the attribute is present with a value of
   * ''. If the value is falsey, the attribute is removed.
   */
  var BooleanAttributePart = function (_AttributePart) {
      inherits(BooleanAttributePart, _AttributePart);

      function BooleanAttributePart() {
          classCallCheck(this, BooleanAttributePart);
          return possibleConstructorReturn(this, (BooleanAttributePart.__proto__ || Object.getPrototypeOf(BooleanAttributePart)).apply(this, arguments));
      }

      createClass(BooleanAttributePart, [{
          key: 'setValue',
          value: function setValue(values, startIndex) {
              var s = this.strings;
              if (s.length === 2 && s[0] === '' && s[1] === '') {
                  var value = getValue(this, values[startIndex]);
                  if (value === noChange) {
                      return;
                  }
                  if (value) {
                      this.element.setAttribute(this.name, '');
                  } else {
                      this.element.removeAttribute(this.name);
                  }
              } else {
                  throw new Error('boolean attributes can only contain a single expression');
              }
          }
      }]);
      return BooleanAttributePart;
  }(AttributePart);
  var PropertyPart = function (_AttributePart2) {
      inherits(PropertyPart, _AttributePart2);

      function PropertyPart() {
          classCallCheck(this, PropertyPart);
          return possibleConstructorReturn(this, (PropertyPart.__proto__ || Object.getPrototypeOf(PropertyPart)).apply(this, arguments));
      }

      createClass(PropertyPart, [{
          key: 'setValue',
          value: function setValue(values, startIndex) {
              var s = this.strings;
              var value = void 0;
              if (this._equalToPreviousValues(values, startIndex)) {
                  return;
              }
              if (s.length === 2 && s[0] === '' && s[1] === '') {
                  // An expression that occupies the whole attribute value will leave
                  // leading and trailing empty strings.
                  value = getValue(this, values[startIndex]);
              } else {
                  // Interpolation, so interpolate
                  value = this._interpolate(values, startIndex);
              }
              if (value !== noChange) {
                  this.element[this.name] = value;
              }
              this._previousValues = values;
          }
      }]);
      return PropertyPart;
  }(AttributePart);
  var EventPart = function () {
      function EventPart(instance, element, eventName) {
          classCallCheck(this, EventPart);

          this.instance = instance;
          this.element = element;
          this.eventName = eventName;
      }

      createClass(EventPart, [{
          key: 'setValue',
          value: function setValue(value) {
              var listener = getValue(this, value);
              if (listener === this._listener) {
                  return;
              }
              if (listener == null) {
                  this.element.removeEventListener(this.eventName, this);
              } else if (this._listener == null) {
                  this.element.addEventListener(this.eventName, this);
              }
              this._listener = listener;
          }
      }, {
          key: 'handleEvent',
          value: function handleEvent(event) {
              if (typeof this._listener === 'function') {
                  this._listener.call(this.element, event);
              } else if (typeof this._listener.handleEvent === 'function') {
                  this._listener.handleEvent(event);
              }
          }
      }]);
      return EventPart;
  }();

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  var keyMapCache = new WeakMap();
  function cleanMap(part, key, map) {
      if (!part.startNode.parentNode) {
          map.delete(key);
      }
  }
  function repeat(items, keyFnOrTemplate, template) {
      var keyFn = void 0;
      if (arguments.length === 2) {
          template = keyFnOrTemplate;
      } else if (arguments.length === 3) {
          keyFn = keyFnOrTemplate;
      }
      return directive(function (part) {
          var keyMap = keyMapCache.get(part);
          if (keyMap === undefined) {
              keyMap = new Map();
              keyMapCache.set(part, keyMap);
          }
          var container = part.startNode.parentNode;
          var index = -1;
          var currentMarker = part.startNode.nextSibling;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
              for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var item = _step.value;

                  var result = void 0;
                  var key = void 0;
                  try {
                      ++index;
                      result = template(item, index);
                      key = keyFn ? keyFn(item) : index;
                  } catch (e) {
                      console.error(e);
                      continue;
                  }
                  // Try to reuse a part
                  var itemPart = keyMap.get(key);
                  if (itemPart === undefined) {
                      var marker = document.createTextNode('');
                      var endNode = document.createTextNode('');
                      container.insertBefore(marker, currentMarker);
                      container.insertBefore(endNode, currentMarker);
                      itemPart = new NodePart(part.instance, marker, endNode);
                      if (key !== undefined) {
                          keyMap.set(key, itemPart);
                      }
                  } else if (currentMarker !== itemPart.startNode) {
                      // Existing part in the wrong position
                      var end = itemPart.endNode.nextSibling;
                      if (currentMarker !== end) {
                          reparentNodes(container, itemPart.startNode, end, currentMarker);
                      }
                  } else {
                      // else part is in the correct position already
                      currentMarker = itemPart.endNode.nextSibling;
                  }
                  itemPart.setValue(result);
              }
              // Cleanup
          } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
          } finally {
              try {
                  if (!_iteratorNormalCompletion && _iterator.return) {
                      _iterator.return();
                  }
              } finally {
                  if (_didIteratorError) {
                      throw _iteratorError;
                  }
              }
          }

          if (currentMarker !== part.endNode) {
              removeNodes(container, currentMarker, part.endNode);
              keyMap.forEach(cleanMap);
          }
      });
  }

  var _templateObject = taggedTemplateLiteral(['\n    <style>\n      .month{width:100%;user-select:none}.month h2{text-align:center;font-size:18px;font-weight:600;color:#2e2e2e}.month .month-grid{padding:10px;border-right:1px solid #ccc}.month .weekdays-container .weekdays .weekday{line-height:32px;width:14.2%;height:35px;text-align:center;display:inline-block}.month .days-containers .day{width:12.2%;height:27px;line-height:27px;display:inline-block;text-align:center;transition:0.2s}.month .days-containers .day:hover{color:white;transition:0.2s;background:#B4D3A2;cursor:pointer;border-radius:50px}.month .days-containers .day.selected{color:white;transition:0.2s;background:#B4D3A2;cursor:pointer;border-radius:50px}.month .days-containers .day.disabled{color:#b9b9b9;font-weight:300;cursor:not-allowed}.month .days-containers .day.disabled:hover{background:white;color:#b9b9b9}@media screen and (max-width: 425px){.month{width:100%}.month .month-grid{padding:0}.month .days-containers .day{height:30px;line-height:29px}.month .weekdays-container .weekdays .weekday{height:31px}}\n\n    </style>\n    <div class="month">\n<h2>', '  ', '</h2>\n<div class="month-grid">\n    <div class="weekdays-container">\n        <div class="weekdays">\n                ', '\n        </div>\n    </div>\n    <div class="days-containers">\n\n            ', '\n    </div>\n</div>\n</div>\n  '], ['\n    <style>\n      .month{width:100%;user-select:none}.month h2{text-align:center;font-size:18px;font-weight:600;color:#2e2e2e}.month .month-grid{padding:10px;border-right:1px solid #ccc}.month .weekdays-container .weekdays .weekday{line-height:32px;width:14.2%;height:35px;text-align:center;display:inline-block}.month .days-containers .day{width:12.2%;height:27px;line-height:27px;display:inline-block;text-align:center;transition:0.2s}.month .days-containers .day:hover{color:white;transition:0.2s;background:#B4D3A2;cursor:pointer;border-radius:50px}.month .days-containers .day.selected{color:white;transition:0.2s;background:#B4D3A2;cursor:pointer;border-radius:50px}.month .days-containers .day.disabled{color:#b9b9b9;font-weight:300;cursor:not-allowed}.month .days-containers .day.disabled:hover{background:white;color:#b9b9b9}@media screen and (max-width: 425px){.month{width:100%}.month .month-grid{padding:0}.month .days-containers .day{height:30px;line-height:29px}.month .weekdays-container .weekdays .weekday{height:31px}}\n\n    </style>\n    <div class="month">\n<h2>', '  ', '</h2>\n<div class="month-grid">\n    <div class="weekdays-container">\n        <div class="weekdays">\n                ', '\n        </div>\n    </div>\n    <div class="days-containers">\n\n            ', '\n    </div>\n</div>\n</div>\n  ']),
      _templateObject2 = taggedTemplateLiteral(['<div class="weekday">', '</div>'], ['<div class="weekday">', '</div>']),
      _templateObject3 = taggedTemplateLiteral(['\n              <div \n                class$="', '"\n                on-click=', '\n                disabled$="', '"\n              >\n                ', '\n              </div>'], ['\n              <div \n                class$="', '"\n                on-click=', '\n                disabled$="', '"\n              >\n                ', '\n              </div>']);

  function _CustomElement() {
    return Reflect.construct(HTMLElement, [], this.__proto__.constructor);
  }
  Object.setPrototypeOf(_CustomElement.prototype, HTMLElement.prototype);
  Object.setPrototypeOf(_CustomElement, HTMLElement);

  // const result = myTemplate({title: 'yay this is awesome', body: 'lit-html is way too cool'});
  // render(result, document.body);


  var zcMonthCalendar = function (_CustomElement2) {
    inherits(zcMonthCalendar, _CustomElement2);
    createClass(zcMonthCalendar, null, [{
      key: 'observedAttributes',
      get: function get$$1() {
        return ['start-year', 'end-year', 'start-month', 'end-month', 'start-time', 'end-time', 'selected-date', 'min-date', 'max-date'];
      }
    }]);

    function zcMonthCalendar() {
      classCallCheck(this, zcMonthCalendar);
      return possibleConstructorReturn(this, (zcMonthCalendar.__proto__ || Object.getPrototypeOf(zcMonthCalendar)).call(this));
    }

    createClass(zcMonthCalendar, [{
      key: 'setProps',
      value: function setProps() {
        var _this2 = this;

        this.startYear = this.getAttribute('start-year');
        this.minDate = this.getAttribute('min-date') ? new Date(this.getAttribute('min-date')) : null;
        this.maxDate = this.getAttribute('max-date') ? new Date(this.getAttribute('max-date')) : null;
        this.endYear = this.getAttribute('end-year');
        this.startMonth = this.getAttribute('start-month');
        this.endMonth = this.getAttribute('end-month');
        this.startTime = this.getAttribute('start-time');
        this.endTime = this.getAttribute('end-time');
        this.today = new Date();
        this.selectedDate = this.getAttribute('selected-date') ? this.getAttribute('selected-date') : null;
        this.month = this.startMonth || this.today.getMonth();
        this.year = this.startYear || this.today.getFullYear();
        this.weekDaysShortLabels = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'];
        this.monthLabels = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        this.setProps = this.setProps.bind(this);
        this.handleDateSelection = this.handleDateSelection.bind(this);
        this.isdateAllowed = this.isdateAllowed.bind(this);
        this.addClassNames = this.addClassNames.bind(this);
        this.firstDay = new Date(this.year, this.month, 1);
        this.startingDay = this.firstDay.getDay();
        this.daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        this.monthLength = this.daysInMonth[this.month];
        if (this.month == 1) {
          if (this.year % 4 === 0 && this.year % 100 !== 0 || this.year % 400 === 0) {
            this.monthLength = 29;
          }
        }      this.monthGridCount = this.monthLength + this.startingDay > 35 ? 42 : 35;
        this.dates = Array.apply(null, { length: this.monthGridCount }).map(function (x, i) {
          i = i + 1;
          var date = i - _this2.startingDay > 0 && i - _this2.startingDay <= _this2.monthLength ? i - _this2.startingDay : false;
          return date || '.';
        });
      }
    }, {
      key: 'addClassNames',
      value: function addClassNames(date) {
        var selectedDate = new Date(this.selectedDate);
        var classNames = ['day'];
        if (selectedDate.getTime() === date.getTime()) classNames.push('selected');
        if (!this.isdateAllowed(date)) classNames.push('disabled');
        return classNames.join(' ');
      }
    }, {
      key: 'isdateAllowed',
      value: function isdateAllowed(date) {
        var isValidDate = isNaN(date.getTime()) ? false : true;
        if (!isValidDate) return false;

        // if date range is not present idea is to enable all the dates.
        var isDateRangePresent = this.maxDate && this.minDate;
        return isDateRangePresent && isValidDate ? date >= this.minDate && date <= this.maxDate : true;
      }
    }, {
      key: 'handleDateSelection',
      value: function handleDateSelection(date) {
        this.selectedDate = date;
        this.updateShadowDom();
        // adding one in month as js dates are 0 based.
        date = parseInt(this.month) + 1 + '/' + date + '/' + this.year;
        if (this.isdateAllowed(new Date(date))) {
          this.dispatchEvent(new CustomEvent('date-tap', { bubbles: true, composed: true, detail: {
              date: date
            } }));
        }
      }
    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        this.createShadowDom();
      }
    }, {
      key: 'createShadowDom',
      value: function createShadowDom() {
        this.attachShadow({ mode: 'open' });
        this.updateShadowDom();
      }
    }, {
      key: 'updateShadowDom',
      value: function updateShadowDom() {
        if (this.shadowRoot) {
          render(this.htmlTemplate, this.shadowRoot);
        }
      }
    }, {
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback(attr, oldVal, newVal) {
        if (oldVal != newVal) {
          this.setProps();
          this.updateShadowDom();
        }
      }
    }, {
      key: 'htmlTemplate',
      get: function get$$1() {
        var _this3 = this;

        return html$1(_templateObject, this.monthLabels[this.month], this.year, repeat(this.weekDaysShortLabels, function (weekDayLabel) {
          return html$1(_templateObject2, weekDayLabel);
        }), repeat(this.dates, function (date) {
          return html$1(_templateObject3, _this3.addClassNames(new Date(parseInt(_this3.month) + 1 + '/' + date + '/' + _this3.year)), function (e) {
            _this3.handleDateSelection(date);
          }, !_this3.isdateAllowed(new Date(parseInt(_this3.month) + 1 + '/' + date + '/' + _this3.year)), date);
        }));
      }
    }]);
    return zcMonthCalendar;
  }(_CustomElement);

  window.customElements.define('zc-month-calendar', zcMonthCalendar);

  var _templateObject$1 = taggedTemplateLiteral(['\n    <style>\n      .time-containers{padding-right:6px}.time-containers .time{text-align:center;transition:0.2s;padding:10px 0;margin:0;font-size:small}.time-containers .time:hover{color:white;transition:0.2s;background:#B4D3A2;cursor:pointer;border-radius:50px}.time-containers .time.selected{color:white;transition:0.2s;background:#B4D3A2;cursor:pointer;border-radius:50px}.time-containers .time.disable{display:none;color:#b9b9b9;font-weight:300;cursor:not-allowed}.time-containers .time.disable:hover{background:white;color:#b9b9b9}@media screen and (max-width: 425px){.time-containers{padding:0}.time-containers .time{padding:7px 0;margin:0;margin-bottom:4px}}\n\n    </style>\n    <!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>Document</title>\n</head>\n<body>\n    <div class="time-containers">\n        ', ' \n    </div>\n\n</body>\n</html>\n  '], ['\n    <style>\n      .time-containers{padding-right:6px}.time-containers .time{text-align:center;transition:0.2s;padding:10px 0;margin:0;font-size:small}.time-containers .time:hover{color:white;transition:0.2s;background:#B4D3A2;cursor:pointer;border-radius:50px}.time-containers .time.selected{color:white;transition:0.2s;background:#B4D3A2;cursor:pointer;border-radius:50px}.time-containers .time.disable{display:none;color:#b9b9b9;font-weight:300;cursor:not-allowed}.time-containers .time.disable:hover{background:white;color:#b9b9b9}@media screen and (max-width: 425px){.time-containers{padding:0}.time-containers .time{padding:7px 0;margin:0;margin-bottom:4px}}\n\n    </style>\n    <!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>Document</title>\n</head>\n<body>\n    <div class="time-containers">\n        ', ' \n    </div>\n\n</body>\n</html>\n  ']),
      _templateObject2$1 = taggedTemplateLiteral(['\n        <p \n          class$="', '"\n          on-click=', '\n        >\n          ', '\n        </p>\n        '], ['\n        <p \n          class$="', '"\n          on-click=', '\n        >\n          ', '\n        </p>\n        ']);

  function _CustomElement$1() {
    return Reflect.construct(HTMLElement, [], this.__proto__.constructor);
  }
  Object.setPrototypeOf(_CustomElement$1.prototype, HTMLElement.prototype);
  Object.setPrototypeOf(_CustomElement$1, HTMLElement);

  var zcTimePicker = function (_CustomElement2) {
    inherits(zcTimePicker, _CustomElement2);
    createClass(zcTimePicker, null, [{
      key: 'observedAttributes',
      get: function get$$1() {
        return ['min-time', 'max-time', 'selected-time'];
      }
    }]);

    function zcTimePicker() {
      classCallCheck(this, zcTimePicker);

      var _this = possibleConstructorReturn(this, (zcTimePicker.__proto__ || Object.getPrototypeOf(zcTimePicker)).call(this));

      _this.selectedTime = null;
      _this.isTimeAllowed = _this.isTimeAllowed.bind(_this);
      _this.convertTo24Hour = _this.convertTo24Hour.bind(_this);
      _this.handleTimeSelection = _this.handleTimeSelection.bind(_this);
      _this.timeInterval = 30;
      _this.timeList = _this._getTimeList(_this.timeInterval);
      return _this;
    }

    createClass(zcTimePicker, [{
      key: '_getTimeList',
      value: function _getTimeList(step) {
        var dateList = [];
        var dt = new Date(1970, 0, 1, 0, 0, 0, 0);
        while (dt.getDate() === 1) {
          dateList.push(this._get12HrTime(dt));
          dt.setMinutes(dt.getMinutes() + step);
        }
        return dateList;
      }
    }, {
      key: 'isTimeAllowed',
      value: function isTimeAllowed(time) {
        var time24h = parseInt(this.convertTo24Hour(time).replace(':', ''));
        var minTime = parseInt(this.minTime.replace(':', ''));
        var maxTime = parseInt(this.maxTime.replace(':', ''));
        return time24h >= minTime && time24h <= maxTime;
      }
    }, {
      key: 'addClassNames',
      value: function addClassNames(time) {
        var classNames = ['time'];
        var time24h = this.convertTo24Hour(time);
        if (!this.isTimeAllowed(time)) classNames.push('disable');
        if (time24h == this.selectedTime) classNames.push('selected');
        return classNames.join(' ');
      }
    }, {
      key: 'convertTo24Hour',
      value: function convertTo24Hour(time12h) {
        var _time12h$split = time12h.split(' '),
            _time12h$split2 = slicedToArray(_time12h$split, 2),
            time = _time12h$split2[0],
            meridiemStatus = _time12h$split2[1];

        var _time$split = time.split(':'),
            _time$split2 = slicedToArray(_time$split, 2),
            hrs = _time$split2[0],
            minutes = _time$split2[1];

        hrs = hrs == '12' ? '00' : hrs;
        hrs = meridiemStatus.toLowerCase() === 'pm' ? parseInt(hrs, 10) + 12 : parseInt(hrs, 10);
        return hrs + ':' + minutes;
      }
    }, {
      key: '_get12HrTime',
      value: function _get12HrTime(time) {
        var t = time.toTimeString().slice(0, 5);
        var hrs = void 0,
            minutes = void 0;

        var _t$split = t.split(':');

        var _t$split2 = slicedToArray(_t$split, 2);

        hrs = _t$split2[0];
        minutes = _t$split2[1];

        var h = hrs % 12 || 12;
        var ampm = hrs < 12 || hrs === 24 ? "AM" : "PM";
        return h + ':' + minutes + ' ' + ampm;
      }
    }, {
      key: '_ifRequiredConvertTo24Hr',
      value: function _ifRequiredConvertTo24Hr(time) {
        var time24h = void 0;
        var ampmRegex = /[p,a].?m.?/ig;
        var isAmPmFormat = ampmRegex.test(time.toLowerCase());
        if (isAmPmFormat) {
          time24h = this.convertTo24Hour(time);
          return time24h;
        }
        return time;
      }
    }, {
      key: 'setProps',
      value: function setProps() {
        this.minTime = this._ifRequiredConvertTo24Hr(this.getAttribute('min-time')) || 0;
        this.maxTime = this._ifRequiredConvertTo24Hr(this.getAttribute('max-time')) || 24;
        this.selectedTime = this._ifRequiredConvertTo24Hr(this.getAttribute('selected-time')) || null;
        // this.visibleMonthCount = this.getAttribute('visible-months') || 6;
      }
    }, {
      key: 'handleTimeSelection',
      value: function handleTimeSelection(time) {
        this.dispatchEvent(new CustomEvent('time-tap', { bubbles: true, composed: true, detail: {
            time: time
          } }));
      }
    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        this.createShadowDom();
      }
    }, {
      key: 'createShadowDom',
      value: function createShadowDom() {
        this.attachShadow({ mode: 'open' });
        this.updateShadowDom();
      }
    }, {
      key: 'updateShadowDom',
      value: function updateShadowDom() {
        if (this.shadowRoot) {
          render(this.htmlTemplate, this.shadowRoot);
        }
      }
    }, {
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback(attr, oldVal, newVal) {
        if (oldVal != newVal) {
          this.setProps();
          this.updateShadowDom();
        }
      }
    }, {
      key: 'htmlTemplate',
      get: function get$$1() {
        var _this2 = this;

        return html$1(_templateObject$1, repeat(this.timeList, function (time, i) {
          return html$1(_templateObject2$1, _this2.addClassNames(time), function (e) {
            _this2.handleTimeSelection(time);
          }, time);
        }));
      }
    }]);
    return zcTimePicker;
  }(_CustomElement$1);

  window.customElements.define('zc-time-picker', zcTimePicker);

  var _templateObject$2 = taggedTemplateLiteral(['', ''], ['', '']),
      _templateObject2$2 = taggedTemplateLiteral(['\n    <style>\n      .cal-wrapper{scroll-behavior:smooth;position:absolute;z-index:2;background:white;border-radius:4px;box-shadow:0 1px 5px #888;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;width:93%;height:325px;max-width:340px;min-width:270px}.cal-wrapper .date-wrapper{width:75%;display:inline-block;overflow-y:scroll;height:325px;scroll-behavior:smooth}.cal-wrapper .done{position:absolute;font-size:18px;text-align:center;font-weight:500;top:10px;margin:0;margin-top:6px;color:#6fbe45;text-transform:uppercase;border:none;outline:none;padding:0;width:22%;background:transparent}.cal-wrapper .time-wrapper{display:inline-block;text-align:center;vertical-align:top;height:260px;margin-top:60px;overflow-y:scroll;width:23%;font-size:14px}@media screen and (max-width: 360px){.cal-wrapper{width:120%}.cal-wrapper .date-wrapper{width:70%}}@media screen and (min-width: 360px) and (max-width: 425px){.cal-wrapper{width:93.5%}.cal-wrapper .date-wrapper{width:75%}.cal-wrapper .done{width:23%;text-align:center;background:transparent}.cal-wrapper .time-wrapper{width:23%;font-size:14px}}\n\n    </style>\n    <!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>Document</title>\n</head>\n<body>\n    <div class="cal-wrapper">\n        <div class="date-wrapper">\n            ', '\n        </div>\n        <button class="done" on-click=', '>Done</button>\n        <div class="time-wrapper">\n            <zc-time-picker \n            on-time-tap=', '\n            selected-time$="', '"\n            min-time$="', '"\n            max-time$="', '"></zc-time-picker>\n        </div>\n    </div>\n\n</body>\n</html>\n  '], ['\n    <style>\n      .cal-wrapper{scroll-behavior:smooth;position:absolute;z-index:2;background:white;border-radius:4px;box-shadow:0 1px 5px #888;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;width:93%;height:325px;max-width:340px;min-width:270px}.cal-wrapper .date-wrapper{width:75%;display:inline-block;overflow-y:scroll;height:325px;scroll-behavior:smooth}.cal-wrapper .done{position:absolute;font-size:18px;text-align:center;font-weight:500;top:10px;margin:0;margin-top:6px;color:#6fbe45;text-transform:uppercase;border:none;outline:none;padding:0;width:22%;background:transparent}.cal-wrapper .time-wrapper{display:inline-block;text-align:center;vertical-align:top;height:260px;margin-top:60px;overflow-y:scroll;width:23%;font-size:14px}@media screen and (max-width: 360px){.cal-wrapper{width:120%}.cal-wrapper .date-wrapper{width:70%}}@media screen and (min-width: 360px) and (max-width: 425px){.cal-wrapper{width:93.5%}.cal-wrapper .date-wrapper{width:75%}.cal-wrapper .done{width:23%;text-align:center;background:transparent}.cal-wrapper .time-wrapper{width:23%;font-size:14px}}\n\n    </style>\n    <!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>Document</title>\n</head>\n<body>\n    <div class="cal-wrapper">\n        <div class="date-wrapper">\n            ', '\n        </div>\n        <button class="done" on-click=', '>Done</button>\n        <div class="time-wrapper">\n            <zc-time-picker \n            on-time-tap=', '\n            selected-time$="', '"\n            min-time$="', '"\n            max-time$="', '"></zc-time-picker>\n        </div>\n    </div>\n\n</body>\n</html>\n  ']),
      _templateObject3$1 = taggedTemplateLiteral(['\n            <zc-month-calendar \n            on-date-tap= ', ' \n            start-year$="', '" \n            start-month$="', '"\n            selected-date$="', '"\n            min-date$="', '"\n            max-date$="', '"\n            ></zc-month-calendar>\n            '], ['\n            <zc-month-calendar \n            on-date-tap= ', ' \n            start-year$="', '" \n            start-month$="', '"\n            selected-date$="', '"\n            min-date$="', '"\n            max-date$="', '"\n            ></zc-month-calendar>\n            ']);

  function _CustomElement$2() {
    return Reflect.construct(HTMLElement, [], this.__proto__.constructor);
  }
  Object.setPrototypeOf(_CustomElement$2.prototype, HTMLElement.prototype);
  Object.setPrototypeOf(_CustomElement$2, HTMLElement);

  var zcCalendar = function (_CustomElement2) {
    inherits(zcCalendar, _CustomElement2);
    createClass(zcCalendar, null, [{
      key: 'observedAttributes',
      get: function get$$1() {
        return ['visible-months', 'min-date', 'max-date', 'min-time', 'max-time', 'selected-time'];
      }
    }]);

    function zcCalendar() {
      classCallCheck(this, zcCalendar);

      var _this = possibleConstructorReturn(this, (zcCalendar.__proto__ || Object.getPrototypeOf(zcCalendar)).call(this));

      _this.today = new Date();
      _this.setProps = _this.setProps.bind(_this);
      _this.handleDateSubmission = _this.handleDateSubmission.bind(_this);
      _this.handleDateTimeSelection = _this.handleDateTimeSelection.bind(_this);
      return _this;
    }

    createClass(zcCalendar, [{
      key: 'handleDateSubmission',
      value: function handleDateSubmission(data) {
        this.dispatchDateTimeChange(true);
      }
    }, {
      key: 'handleDateTimeSelection',
      value: function handleDateTimeSelection(data) {
        if (data.detail.time) this.selectedTime = data.detail.time;
        if (data.detail.date) this.selectedDate = data.detail.date;
        this.updateShadowDom();
        this.dispatchDateTimeChange();
      }
    }, {
      key: 'dispatchDateTimeChange',
      value: function dispatchDateTimeChange() {
        var isSubmitted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        this.dispatchEvent(new CustomEvent('datetime-change', { bubbles: true, composed: true, detail: {
            time: this.selectedTime,
            date: this.selectedDate,
            isSubmitted: isSubmitted
          } }));
      }
    }, {
      key: 'setProps',
      value: function setProps() {
        var _this2 = this;

        this.minDate = this.getAttribute('min-date');
        this.maxDate = this.getAttribute('max-date');
        this.selectedDate = this.getAttribute('selected-date');
        this.selectedTime = this.getAttribute('selected-time');
        this.minTime = this.getAttribute('min-time') || '00:00';
        this.maxTime = this.getAttribute('max-time') || '23:30';
        this.visibleMonthCount = this.getAttribute('visible-months') || 6;
        this.months = Array.apply(null, { length: this.visibleMonthCount }).map(function (x, i) {
          var result = new Date(_this2.today);
          result.setDate(1);
          result.setMonth(i + _this2.today.getMonth());
          return result;
        });
        this.monthsTemplate = html$1(_templateObject$2, this.months.join(' '));
      }
    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        this.createShadowDom();
      }
    }, {
      key: 'createShadowDom',
      value: function createShadowDom() {
        this.attachShadow({ mode: 'open' });
        this.updateShadowDom();
      }
    }, {
      key: 'updateShadowDom',
      value: function updateShadowDom() {
        if (this.shadowRoot) {
          render(this.htmlTemplate, this.shadowRoot);
        }
      }
    }, {
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback(attr, oldVal, newVal) {
        if (oldVal != newVal) {
          this.setProps();
          this.updateShadowDom();
        }
      }
    }, {
      key: 'htmlTemplate',
      get: function get$$1() {
        var _this3 = this;

        return html$1(_templateObject2$2, repeat(this.months, function (month, i) {
          return html$1(_templateObject3$1, function (data) {
            return _this3.handleDateTimeSelection(data);
          }, month.getFullYear(), month.getMonth(), _this3.selectedDate, _this3.minDate, _this3.maxDate);
        }), function (e) {
          _this3.handleDateSubmission();
        }, function (data) {
          return _this3.handleDateTimeSelection(data);
        }, this.selectedTime, this.minTime, this.maxTime);
      }
    }]);
    return zcCalendar;
  }(_CustomElement$2);

  window.customElements.define('zc-calendar', zcCalendar);

}());
